# Dec207Hub Backend Chat Handler
# Qwen2.5-Coder-14B + Function Calling + ABAP 최적화

import json
import httpx
import logging
import re
from datetime import datetime
from typing import List, Dict, Any, Optional
from config import (
    OLLAMA_BASE_URL, DEFAULT_MODEL, FALLBACK_MODEL, HTTP_TIMEOUT, 
    MAX_CONVERSATION_HISTORY, MAX_CONTEXT_MESSAGES, MAX_MESSAGE_LENGTH,
    AI_TEMPERATURE, AI_TOP_P, AI_REPEAT_PENALTY, AI_MAX_NEW_TOKENS,
    ENABLE_MCP, ENABLE_FUNCTION_CALLING, ENABLE_FACT_CHECK, UNCERTAINTY_THRESHOLD
)

logger = logging.getLogger(__name__)

async def chat_with_ollama(message: str, model: str = DEFAULT_MODEL, 
                          conversation_history: List[Dict] = None,
                          enable_tools: bool = True) -> str:
    """Qwen2.5-Coder-14B와 고급 채팅 - Function Calling 및 ABAP 최적화"""
    try:
        async with httpx.AsyncClient(timeout=HTTP_TIMEOUT) as client:
            # 대화 컨텍스트 구성 (확장된 히스토리)
            context_prompt = build_enhanced_context_prompt(conversation_history)
            
            # ABAP 특화 프롬프트 구성
            enhanced_prompt = build_abap_optimized_prompt(context_prompt, message)
            
            # Function Calling 지원 페이로드
            payload = build_enhanced_payload(model, enhanced_prompt, enable_tools)
            
            logger.info(f"Qwen2.5-Coder-14B에 요청 전송: {message[:50]}...")
            response = await client.post(f"{OLLAMA_BASE_URL}/api/chat", json=payload)
            
            if response.status_code == 200:
                data = response.json()
                
                # AI 응답 추출 및 처리
                ai_response = extract_and_process_response(data, message)
                
                # 할루시네이션 검증
                if ENABLE_FACT_CHECK:
                    ai_response = validate_response_accuracy(ai_response, message)
                
                logger.info(f"Qwen2.5-Coder-14B 응답 완료: {ai_response[:50]}...")
                return ai_response
            else:
                logger.error(f"Ollama API 오류: {response.status_code}")
                # 백업 모델 시도
                return await fallback_model_chat(message, conversation_history)
                
    except httpx.TimeoutException:
        logger.error("Qwen2.5-Coder-14B 응답 시간 초과")
        return await fallback_model_chat(message, conversation_history)
    except Exception as e:
        logger.error(f"Qwen2.5-Coder-14B 통신 오류: {str(e)}")
        return f"AI 서버 연결 오류: {str(e)}"

def build_enhanced_context_prompt(conversation_history: List[Dict]) -> str:
    """향상된 대화 컨텍스트 프롬프트 구성"""
    context_prompt = ""
    if conversation_history and len(conversation_history) > 0:
        # 중복 제거 및 컨텍스트 정리
        unique_history = []
        seen_messages = set()
        
        for msg in reversed(conversation_history[-MAX_CONVERSATION_HISTORY:]):
            msg_content = msg.get('content', '').strip()
            if msg_content and msg_content not in seen_messages:
                unique_history.append(msg)
                seen_messages.add(msg_content)
                if len(unique_history) >= MAX_CONTEXT_MESSAGES:
                    break
        
        if unique_history:
            context_prompt = "=== 이전 대화 컨텍스트 ===\n"
            for msg in reversed(unique_history):
                role_display = "👤 사용자" if msg.get('role') == 'user' else "🤖 AI"
                content = msg.get('content', '')[:MAX_MESSAGE_LENGTH]
                context_prompt += f"{role_display}: {content}\n"
            context_prompt += "\n=== 현재 질문 ===\n"
    
    return context_prompt

def build_abap_optimized_prompt(context_prompt: str, message: str) -> str:
    """ABAP 개발 최적화 프롬프트 구성"""
    
    # ABAP 관련 키워드 검사
    abap_keywords = ['abap', 'sap', 'select', 'data:', 'form', 'function', 'report', 'table']
    is_abap_related = any(keyword in message.lower() for keyword in abap_keywords)
    
    if is_abap_related:
        return f"""당신은 SAP ABAP 개발 전문가입니다. Qwen2.5-Coder-14B의 강력한 코딩 능력을 활용하여 최고 품질의 ABAP 솔루션을 제공하세요.

**ABAP 개발 전문 규칙:**
1. **정확한 ABAP 문법** 사용 - 문법 오류 절대 금지
2. **SAP 베스트 프랙티스** 준수 - 성능과 유지보수성 고려
3. **버전 호환성** 명시 - ECC, S/4HANA, BTP 구분
4. **명명 규칙** 준수 - SAP 표준 변수명 사용
5. **주석 포함** - 코드 이해도 향상
6. **에러 처리** 포함 - 예외 상황 대비
7. **성능 최적화** - SELECT 문 최적화, 내부 테이블 효율적 사용

**코딩 품질 보장:**
- 존재하지 않는 SAP 함수나 테이블을 만들어내지 않음
- 확실하지 않은 ABAP 구문은 대안 제시
- 코드 설명과 함께 실행 가능한 예제 제공

**응답 형식:**
```abap
" 주석으로 설명
" 코드 작성
```

{context_prompt}

**ABAP 질문**: {message}

**전문가 답변**:"""
    else:
        return f"""당신은 Qwen2.5-Coder-14B 기반의 고급 AI 어시스턴트입니다. 강화된 추론 능력과 코딩 실력을 바탕으로 최고 품질의 답변을 제공하세요.

**고급 답변 규칙:**
1. **정확성 우선** - 확실하지 않으면 솔직히 인정
2. **논리적 추론** - 단계별 사고 과정 제시  
3. **실용적 솔루션** - 실제 사용 가능한 답변
4. **코드 품질** - 주석과 설명이 포함된 완성도 높은 코드
5. **다양한 관점** - 여러 접근 방법 제시
6. **최신 정보** - 2025년 기준 최신 기술 반영
7. **한국어 전용** - 자연스럽고 정확한 한국어 사용

**할루시네이션 방지:**
- 존재하지 않는 정보 제작 금지
- 불확실한 내용은 "확실하지 않습니다" 명시
- 추측과 사실 구분하여 제시

{context_prompt}

**질문**: {message}

**고급 AI 답변**:"""

def build_enhanced_payload(model: str, prompt: str, enable_tools: bool) -> Dict[str, Any]:
    """향상된 페이로드 구성 - Function Calling 지원"""
    payload = {
        "model": model,
        "messages": [
            {
                "role": "user", 
                "content": prompt
            }
        ],
        "stream": False,
        "options": {
            "temperature": AI_TEMPERATURE,
            "top_p": AI_TOP_P,
            "repeat_penalty": AI_REPEAT_PENALTY,
            "num_predict": AI_MAX_NEW_TOKENS,
            "num_ctx": 128000,  # 128K 컨텍스트 활용
        }
    }
    
    # Function Calling 활성화 시 도구 추가
    if enable_tools and ENABLE_FUNCTION_CALLING:
        # 추후 MCP 도구 연동 시 여기에 tools 배열 추가
        pass
    
    return payload

def extract_and_process_response(data: Dict[str, Any], original_message: str) -> str:
    """AI 응답 추출 및 후처리"""
    ai_response = data.get("message", {}).get("content", "응답을 생성할 수 없습니다.").strip()
    
    # ABAP 코드 검증
    if 'abap' in original_message.lower():
        ai_response = validate_abap_syntax(ai_response)
    
    # 일반 후처리
    ai_response = clean_enhanced_response(ai_response)
    
    return ai_response

def validate_abap_syntax(response: str) -> str:
    """ABAP 문법 기본 검증"""
    # 기본적인 ABAP 문법 패턴 검사
    common_errors = [
        (r'SELECT \* FROM', 'SELECT * FROM → 성능상 문제가 있을 수 있습니다. 필요한 필드만 선택하는 것을 권장합니다.'),
        (r'INTO TABLE lt_\w+ FROM', '내부 테이블 선언이 누락되었을 수 있습니다.'),
    ]
    
    for pattern, warning in common_errors:
        if re.search(pattern, response, re.IGNORECASE):
            response += f"\n\n⚠️ **주의사항**: {warning}"
    
    return response

def validate_response_accuracy(response: str, question: str) -> str:
    """응답 정확성 검증 (할루시네이션 방지)"""
    # 의심스러운 패턴 검사
    suspicious_patterns = [
        r'새로운?\s*(기술|제품|기능).*출시',
        r'최근에?\s*발표된',
        r'2025년.*이후',
        r'확실한?\s*정보.*있습니다',
        r'공식.*발표'
    ]
    
    uncertainty_indicators = [
        '추측', '아마도', '가능성', '~인 것 같습니다', '확실하지 않지만'
    ]
    
    # 의심스러운 패턴 감지
    for pattern in suspicious_patterns:
        if re.search(pattern, response, re.IGNORECASE):
            response = f"⚠️ **정확성 주의**: 이 답변에는 불확실한 정보가 포함될 수 있습니다.\n\n{response}\n\n💡 **권장사항**: 중요한 정보는 공식 문서나 최신 소스에서 재확인해주세요."
            break
    
    # 불확실성 지표 확인
    uncertainty_count = sum(1 for indicator in uncertainty_indicators if indicator in response)
    if uncertainty_count >= 2:
        response += f"\n\n🤔 **참고**: 이 답변에는 불확실한 내용이 포함되어 있으니 참고용으로만 활용해주세요."
    
    return response

def clean_enhanced_response(response: str) -> str:
    """향상된 AI 응답 정리"""
    # 과도한 줄바꿈 정리
    response = re.sub(r'\n{4,}', '\n\n', response)
    response = re.sub(r'\n{3}', '\n\n', response)
    
    # 불필요한 특수기호 제거
    response = re.sub(r'[\u2605\u2606\u25a0\u25cf\u25cb\u2661\u2665\u2668\u266a\u266b]{2,}', '', response)
    
    # 시작/끝 공백 제거
    response = response.strip()
    
    return response

async def fallback_model_chat(message: str, conversation_history: List[Dict] = None) -> str:
    """백업 모델(qwen2.5-coder:7b)로 대체 실행"""
    try:
        logger.info(f"백업 모델 {FALLBACK_MODEL}로 전환")
        return await chat_with_ollama(message, FALLBACK_MODEL, conversation_history, enable_tools=False)
    except Exception as e:
        logger.error(f"백업 모델도 실패: {str(e)}")
        return f"죄송합니다. 현재 AI 서비스에 일시적인 문제가 있습니다. 잠시 후 다시 시도해주세요. (오류: {str(e)})"

# 유틸리티 함수들
def is_abap_question(message: str) -> bool:
    """ABAP 관련 질문인지 판단"""
    abap_indicators = [
        'abap', 'sap', 'select', 'data:', 'form', 'function', 'report', 'table',
        'internal table', '내부 테이블', 'bapi', 'rfc', 'smartform', 'adobe form'
    ]
    return any(indicator in message.lower() for indicator in abap_indicators)

def get_model_status() -> Dict[str, Any]:
    """모델 상태 정보 반환"""
    return {
        "primary_model": DEFAULT_MODEL,
        "fallback_model": FALLBACK_MODEL,
        "function_calling": ENABLE_FUNCTION_CALLING,
        "mcp_enabled": ENABLE_MCP,
        "fact_check": ENABLE_FACT_CHECK,
        "max_tokens": AI_MAX_NEW_TOKENS,
        "context_window": 128000
    }

logger.info("🚀 Qwen2.5-Coder-14B Chat Handler 로드 완료")
logger.info(f"🎯 메인 모델: {DEFAULT_MODEL}")
logger.info(f"🔧 백업 모델: {FALLBACK_MODEL}")
logger.info(f"🛠️ Function Calling: {'활성화' if ENABLE_FUNCTION_CALLING else '비활성화'}")
